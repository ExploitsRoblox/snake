<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slither.io Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; cursor: crosshair; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: white; pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .controls { font-size: 14px; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>

    <div id="ui">
        <div id="score" style="font-size: 32px; font-weight: bold;">Pontos: 0</div>
        <div class="controls">Mova o mouse para guiar • Segure clique para TURBO</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let score = 0;
        let gameOver = false;
        let foods = [];
        let enemies = [];
        let isBoosting = false;

        // Configurações do Jogo
        const FOOD_COUNT = 60;
        const ENEMY_COUNT = 6;

        class Snake {
            constructor(x, y, color, isPlayer = false) {
                this.pos = { x, y };
                this.segments = [];
                this.length = 25;
                this.radius = 12;
                this.baseSpeed = 3;
                this.speed = 3;
                this.angle = Math.random() * Math.PI * 2;
                this.color = color;
                this.isPlayer = isPlayer;
                this.dead = false;
            }

            update(targetX, targetY, boost = false) {
                if (this.dead) return;

                // Lógica de Turbo
                if (boost && this.length > 10) {
                    this.speed = this.baseSpeed * 2;
                    if (Math.random() > 0.8) this.length -= 0.2; // Perde tamanho ao usar turbo
                } else {
                    this.speed = this.baseSpeed;
                }

                // Interpolação do ângulo (suaviza a curva)
                const targetAngle = Math.atan2(targetY - this.pos.y, targetX - this.pos.x);
                let angleDiff = targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                this.angle += angleDiff * 0.15;

                // Movimento
                this.pos.x += Math.cos(this.angle) * this.speed;
                this.pos.y += Math.sin(this.angle) * this.speed;

                // Gerenciar segmentos (corpo)
                this.segments.unshift({ x: this.pos.x, y: this.pos.y });
                if (this.segments.length > this.length) this.segments.pop();

                this.checkFoodCollision();
                this.checkBounds();
            }

            checkFoodCollision() {
                for (let i = foods.length - 1; i >= 0; i--) {
                    const f = foods[i];
                    const dist = Math.hypot(f.x - this.pos.x, f.y - this.pos.y);
                    if (dist < this.radius + f.radius) {
                        this.length += f.isLoot ? 4 : 2;
                        if (this.isPlayer) {
                            score += f.isLoot ? 25 : 10;
                            scoreElement.innerText = `Pontos: ${score}`;
                        }
                        foods.splice(i, 1);
                        if (!f.isLoot) foods.push(createFood());
                    }
                }
            }

            checkBounds() {
                if (this.pos.x < 0 || this.pos.x > canvas.width || 
                    this.pos.y < 0 || this.pos.y > canvas.height) {
                    this.die();
                }
            }

            draw() {
                if (this.dead) return;
                
                // Desenhar corpo
                ctx.shadowBlur = 0;
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    if (i % 5 === 0) {
                        const seg = this.segments[i];
                        ctx.beginPath();
                        ctx.arc(seg.x, seg.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = this.color;
                        ctx.fill();
                        ctx.closePath();
                    }
                }

                // Desenhar Olhos na Cabeça
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.closePath();
            }

            die() {
                if (this.dead) return;
                this.dead = true;
                // Transforma corpo em Loot
                this.segments.forEach((seg, i) => {
                    if (i % 6 === 0) {
                        foods.push({
                            x: seg.x, y: seg.y, radius: 8, 
                            color: this.color, isLoot: true 
                        });
                    }
                });

                if (this.isPlayer) {
                    gameOver = true;
                    setTimeout(() => location.reload(), 2000);
                }
            }
        }

        // Inicialização
        function createFood(isLoot = false) {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: isLoot ? 8 : 5,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                isLoot: isLoot
            };
        }

        const player = new Snake(canvas.width / 2, canvas.height / 2, '#00ff88', true);
        for (let i = 0; i < FOOD_COUNT; i++) foods.push(createFood());
        for (let i = 0; i < ENEMY_COUNT; i++) {
            enemies.push(new Snake(Math.random() * canvas.width, Math.random() * canvas.height, '#ff4444'));
        }

        // Input
        const mouse = { x: 0, y: 0 };
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => isBoosting = true);
        window.addEventListener('mouseup', () => isBoosting = false);

        function checkCollisions() {
            const allSnakes = [player, ...enemies];
            
            allSnakes.forEach(s1 => {
                if (s1.dead) return;
                
                allSnakes.forEach(s2 => {
                    if (s2.dead) return;
                    
                    // Se a cabeça de s1 bater no corpo de s2
                    s2.segments.forEach((seg, index) => {
                        // Não colidir com a própria cabeça (primeiros segmentos)
                        if (s1 === s2 && index < 15) return;
                        
                        const dist = Math.hypot(s1.pos.x - seg.x, s1.pos.y - seg.y);
                        if (dist < s1.radius + s2.radius - 5) {
                            s1.die();
                        }
                    });
                });
            });
        }

        function update() {
            if (!gameOver) {
                player.update(mouse.x, mouse.y, isBoosting);
            }

            enemies.forEach(en => {
                if (en.dead) {
                    if (Math.random() < 0.005) { // Chance de renascer
                        en.dead = false;
                        en.pos = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
                        en.length = 25;
                    }
                    return;
                }
                
                // IA Simples: Segue a comida mais próxima
                let target = foods[0];
                en.update(target.x, target.y, false);
            });

            checkCollisions();
        }

        function draw() {
            // Fundo com leve rastro (efeito motion blur)
            ctx.fillStyle = 'rgba(26, 26, 26, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            foods.forEach(f => {
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                if (f.isLoot) { ctx.shadowBlur = 10; ctx.shadowColor = f.color; }
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            enemies.forEach(en => en.draw());
            if (!gameOver) player.draw();
            else {
                ctx.fillStyle = "white";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>